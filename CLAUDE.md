# CLAUDE.md

Instructions for Claude Code when working with this repository.

## Overview

Modular dotfiles repository with unified `ctdev` CLI. Cross-platform support for macOS, Ubuntu, Debian, Fedora, and Arch.

## ctdev CLI

```bash
ctdev install [component...]    # Install components (all if none specified)
ctdev update [component...]     # Update system and installed components
ctdev info                      # Show system info and check installation health
ctdev list                      # List available components
ctdev uninstall <component...>  # Remove components
ctdev setup                     # Symlink ctdev to ~/.local/bin
```

**Flags:** `--help`, `--verbose`, `--dry-run`, `--version`

**Update-specific flags:** `--skip-system` (skip system package updates)

**Auto-update:** ctdev checks for repo updates before any command and prompts to pull if behind origin.

**install vs update:**
- `install` only installs new components; prompts if updates are available
- `update` updates system packages and installed components

## Components

| Component | Description |
|-----------|-------------|
| apps | Desktop applications (Chrome, VSCode, Slack, etc.) |
| cli | CLI tools (jq, gh, kubectl, btop, git-spice, etc.) |
| fonts | Nerd Fonts |
| git | Git configuration |
| node | Node.js via nodenv |
| ruby | Ruby via rbenv |
| zsh | Zsh, Oh My Zsh, Pure prompt, plugins |

## Directory Structure

```
dotfiles/
├── ctdev                 # CLI entry point (resolves symlinks)
├── lib/
│   ├── utils.sh         # Main entry point, sources all lib modules
│   ├── logging.sh       # Color config and log_* functions
│   ├── platform.sh      # OS/arch detection, package management
│   ├── packages.sh      # Dependency management helpers
│   ├── github.sh        # GitHub API, checksums, git repo functions
│   ├── cli.sh           # CLI parsing and help text
│   └── components.sh    # Component registry
├── cmds/
│   ├── install.sh       # Install command
│   ├── update.sh        # Update command
│   ├── list.sh          # List command
│   ├── info.sh          # Info command
│   ├── uninstall.sh     # Uninstall command
│   └── setup.sh         # Setup command
├── components/
│   ├── apps/            # Desktop apps (individual .sh per app)
│   ├── cli/             # CLI tools (individual .sh per tool)
│   ├── fonts/           # Nerd Fonts
│   ├── git/             # Git config
│   ├── node/            # Node.js
│   ├── ruby/            # Ruby
│   └── zsh/             # Zsh config
├── shell/               # Shell config (symlinked to ~/.oh-my-zsh/custom/)
└── VERSION
```

## Key Utilities (lib/utils.sh)

**Logging:** `log_info`, `log_success`, `log_warning`, `log_error`, `log_step`, `log_debug`

**Platform:** `detect_os`, `detect_arch`, `get_package_manager`, `is_macos`, `is_linux`, `maybe_sudo`

**Files:** `safe_symlink`, `backup_file`, `run_cmd` (respects DRY_RUN)

**Packages:** `install_package`, `install_brew_cask`, `ensure_git_repo`

## Git Commits

- Use single-line commit messages
- No "Co-Authored-By" or "Generated by" footers

## Releases

When asked to "make a release", do all of the following:

1. **Commit changes** with appropriate commit message
2. **Update CHANGELOG.md** with new version entry and changes
3. **Update README.md** if the feature affects user-facing documentation
4. **Bump VERSION file** (patch version for fixes/small features, minor for larger features)
5. **Commit doc updates** with message like `docs: update for vX.Y.Z`
6. **Create git tag** (`git tag vX.Y.Z`)
7. **Push commits and tags** (`git push && git push --tags`)
8. **Create GitHub release** via `gh release create vX.Y.Z` with release notes summarizing changes

## Conventions

- All scripts use `#!/usr/bin/env bash` and `set -euo pipefail`
- Scripts are idempotent (safe to re-run)
- Use `maybe_sudo` instead of `sudo` for Docker compatibility
- Use `run_cmd` to respect DRY_RUN flag
- macOS uses Homebrew; Linux uses apt/dnf/pacman
- Symlink configs instead of copying

## Adding Components

1. Create script in `components/<name>/install.sh`
2. Source `lib/utils.sh` for utilities
3. Use `log_*` functions for output
4. Respect `DRY_RUN` via `run_cmd`
5. Add to `COMPONENTS` array in `lib/components.sh`

## Adding CLI Tools

Create `components/cli/<tool>.sh`:
```bash
#!/usr/bin/env bash
set -euo pipefail
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../../lib/utils.sh"

if command -v <tool> >/dev/null 2>&1; then
  log_info "<tool> already installed"
  exit 0
fi

OS=$(detect_os)
if [[ "$OS" == "macos" ]]; then
  brew install <tool>
else
  install_package <tool>
fi
```

Then add to `components/cli/install.sh`.
